\documentclass{article}

\include{preamble}

\title{Technical Report}
\author{Allan Jones}
\begin{document}
	\maketitle

\begin{abstract}
	
\end{abstract}

\section{Abstract}

\crumbs{Put an emphasis on applications with content that is user-generated/crowd-sourced, as these are the kinds of application that scale up in data/traffic easily...bring mobile into context as the traffic increases with the introduction of mobile as people are now more connected than they once were}
\excrumbs{Mobile applications that hook into web applications are becoming more and more popular as the number of web-enabled smart phones increases}
\excrumbs{As the number of users of these application increases, thus increasing the amount of data generated by the user base, providing the correct data to user becomes a far more difficult challenge in terms of mining the datastore for this information}
\excrumbs{This report presents the problem of scalability in user-driven web applications and details a potential solution built upon the Google App Engine platform that addresses some of these issues.}

\section{Introduction} % (fold)
\label{sec:introduction}

\crumbs{Present the problem faced when providing fast access to location-sensitive data}

\crumbs{Present a potential solution for organising and providing location-sensitive data for consumption by mobile applications that is built on top of Google App Engine}
 
\crumbs{Describe the architecture and algorithm used to organise the data}

% section introduction (end)

\section{Background and Content} % (fold)
\label{sec:background_and_content}

\crumbs{TODO: Include some existing work in the field here}

\crumbs{The popularity of web-enabled smart phones is increasing at an astounding rate}

\crumbs{This is allowing us to take our social networks on the go...}

\crumbs{A lot of social networks are evolving to include functionality that operates based the location of a user, allowing for a more immersive experience for users, especially when out in public}

\crumbs{TODO: Practical examples of using location-based functionality}

\crumbs{As people take their mobile phones out and about with them, there is no guarantee that they will have a fast internet connection}

\crumbs{Mobile users are impatient and will not wait forever for their data to be downloaded}

\crumbs{These challenges become even more evident when we are faced with the issue of providing data that is specific to a certain criteria, such as personalized, time or location sensitive, requiring a targeted search for the data we want}

\crumbs{This becomes even more evident in social networking applications, which can potentially have very large amounts of data, which make looking for the right data like finding a needle in a haystack}

% section background_and_content (end)

\section{Technical Detail} % (fold)
\label{sec:technical_detail}

\subsection{Problem Details} % (fold)
\label{sub:problem_details}

\crumbs{Start with the constraints of the problem -- users can receive data only within a certain location and within a certain time}

\crumbs{With that in mind, we should approach the problem by organising data that is within the same location and is relevant in the same time frame}

\crumbs{However, we do not want to retrieve large amounts of data at once, nor we want to have to query for an adequately small and selective amount of data (server processing is expensive, especially when the app has to scale)}

\subsubsection{Data Model} % (fold)
\label{ssub:data_model}

For the purposes of this report we describe a simplified domain model for a social networking application. The model consists of two core entities: \emph{user} and \emph{message}

% subsubsection data_model (end)

\subsubsection{Constraints} % (fold)
\label{ssub:constraints}

\textbf{What are we aiming for with our design?}

In order tailor a solution to the problem, the problem itself required a slightly more specific definition.

The following constraints were outlined in designing a solution to the problem:

\begin{itemize}

	\item Users are able to receive a maximum of 50 messages for a given request
	\item A single message will no larger than \textbf{TODO: Give a size limit for message}
	\item A single request to the server should yield no more than \textbf{TODO: Give a size limit for request} worth of response data
	\item A single request should take no longer than 5 seconds (from initiation of the request to retrieval of a response and display on the phone)
	\item Provided there is data available for a location, a request should never yield no response data
\end{itemize}

% subsubsection constraints (end)

% subsection problem_details (end)

\subsection{Solution Details} % (fold)
\label{sub:solution_details}

% subsection solution_details (end)

\subsubsection{Message Grouping} % (fold)
\label{ssub:organisation_strategy}

\draft{In choosing how to effectively group the messages, it was important to understand the criteria according to which messages are retrieved. For this problem, the messages are retrieved according to both the location of a retriever, as well as point in time for which they are interested in. In most cases, this will be the current time, however it was necessary to also consider the possibly of the retrieval of messages that were created at some point in time that is outside a definition of time that can be considered time.}

\draft{If we were to group according to continuous points (i.e., latitude/longitude), there are potentially infinite locations that could be represented. While this can be resolved by using lat/long values that are trimmed to a given precision, it is more sensible and closer to the problem to represent the earth's landscape as a collection of geospatial areas, which contains the latitude/longitude coordinates that the messages are relevant for.}

\crumbs{Time elasticity}

% paragraph message_grouping (end)

\subsubsection{GeoModel} % (fold)

\excrumbs{Utilised the GeoModel API, which is designed for indexing and querying of geospatial data within Google App Engine.}

\excrumbs{The GeoModel API provides a geospatial representation of the earth that is based upon geohashing \textbf{TODO: Cite geohash/geohashing}}

\excrumbs{The API represents the world as a 4x4 grid, with each cell within the grid being marked by a character from 0-f.
Within each of those cells is another 4x4 grid of cells. This grid definition within a cell is recursive, with each grid cell possessing 4x4 cells to a resolution of 16.}

\excrumbs{As an example, the strings \textbf{745e43a1} and \textbf{745e43a2} represent the the coordinates from x to y and y to z respectively, while 745e43a encompasses both of these regions, as well as the rest \textbf{TODO: Put the full range of cells in here}}

\excrumbs{Using this approach, we can define an area of space this is elastic, i.e. we can define a bigger or smaller space simply by combining grid cells.
\textbf{TODO: Need the measurements for upper and lower resolution limit}}

\excrumbs{\textbf{TODO: Probably need to bring this into context somewhere earlier on}
To define a resolution suitable for data retrieval for mobile devices, an experiment was conducted using iPhones to determine the accuracy to which the GPS within the phones was able to determine the phone's location.}

\excrumbs{The experiment found that, on average, the location's determined by the phone were within 500 metres of accuracy. To cater for this lack of precision a cell size of \textbf{TODO: get the actual cell size} was used.}

\subsubsection{Message Buckets} % (fold)

\crumbs{Explain the concept of buckets}

\crumbs{Highlight the fact that the buckets are essentially strung together to form a timeline}

\crumbs{Detail how we have structured the buckets, including size, data stored in the buckets, implementation details such as linking buckets together and associated message creation/expiry dates}

\crumbs{TODO: Diagram of message bucket design}

\crumbs{TODO: Diagram of bucket overflow and the creation of new buckets}

\subsubsection{Preparation of Buckets} % (fold)
\label{ssub:preparation_of_buckets}

\crumbs{Explain the implementation of the algorithm, referring to the code figures as needed}

%------------------------------------------------------------------------------
\begin{center}
\begin{minipage}{5.5in}%
\begin{python}[caption={Bucket Preparation Algorithm in Python},label={code:ec_GA}] 

def	prepare_buckets_for_public_messages():
  # Get a hash of geocell -> uncprocessed messages hash
  geocell_message_hash = get_unprocessed_message_hash()

  # For each geo-cell to message hash entry
  for geocell, message_hash in geocell_message_hash.iteritems():
  # Store the number of messages to process
    unprocessed_messages = message_hash["count"]
    total_messages_to_process = unprocessed_messages

    top_bucket = self.get_top_public_bucket(geocell, message_hash["geocells"])

	message_count_for_bucket = self.fill_bucket(top_bucket, message_hash["events"], 0)

	# Decrease the messages left to process
	unprocessed_messages = unprocessed_messages - message_count_for_bucket
	top_bucket.put()

	# While there are still messages to store, create a bucket, mark it as top and store as many
	# messages as possible in it   
    while unprocessed_messages > 0:
	  # Mark the current top bucket as not being the top bucket any longer
	  top_bucket.status = 0
	  new_bucket = make_new_public_bucket(message_hash["geocells"])
	  # Get the index of the next message to be processed
	  next_message_index = total_messages_to_process - unprocessed_messages
	  message_count_for_bucket = fill_bucket(new_bucket, message_hash["events"], next_message_index)
	  # Decrease the messages to process according to how many were stored in the bucket
	  unprocessed_messages -= message_count_for_bucket
	  # Flag the new bucket as the top
	  new_bucket.status = Constants.PUBLIC_BUCKET_STATUS_TOP
	  top_bucket.put()
	  new_bucket.put()
	  # Set top bucket as the new bucket created
	  top_bucket = new_bucket
\end{python}
\end{minipage}
\end{center}
%------------------------------------------------------------------------------


% subsubsection preparation_of_buckets (end)

% section technical_detail (end)

\section{Discussion} % (fold)
\label{sec:discussion}

\crumbs{Highlight any preliminary results that have been obtained through testing of the implementation} 

\crumbs{Discuss possible shortcomings of the current approach \textbf{TODO: May need a Limitations subsection with the Technical section}}

% section discussion (end)

\section{Conclusion} % (fold)
\label{sec:conclusion}

\crumbs{Summarise the design that was outlined within the report}

\crumbs{Highlight the implications of the design proposed}

\crumbs{Outline the next steps based on this tech report}

% section conclusion (end)

\end{document}

% - Social media applications are become integrated within our daily lives
% 
% - Effective means of communication and information discovery
% 
% - Most of them are free...users like free stuff!
% 
% - Mobile applications enable users to be out and about while surfing the web, something that wasn't really possible previously
% 
% - There is stuff to do when users are out and about, which social media apps can enhance

% - Some social media apps are super rich in content and have a substantial base of users
% 
% - This is a great thing, but somewhere this data needs to be stored (huge amounts of data!)
% 
% - Additionally, not every user is going to want every bit of data
% 
% - A search for personalised data (i.e. data that an individual user cares about) at a large-scale can be computationally expensive and slow (users don't like to wait!)
% 
% - Caching alleviates this problem to some extent (allows computations to occur a smaller number of times, with the results stored -- caching tier is much lower latency than the datastore)
% 
% - Problem is, that this doesn't come cheap
% 
% - Cached data is not persistent (caching tier is separate from DB)
% 
% - Need to ensure cache is not invalid (we need to provide users with the data they want)
% 
% - As the number of users increases, it becomes less practical to provide high-availability/throughput personalized information
% 
% - We need to make trade-offs, based on the problem space (no of users, user usage patterns, distribution of data -- location-based)
% 
% 
% \textbf{Focus should be on mobile devices}

% - Mobile devices are becoming more and more sophisticated, especially with advances in GPS technology, which enables the device to know where it is at a given time. This capability holds the potential of allowing application developers to enrich their applications by enabling their application to perform functionality that is location sensitive. Some practical examples of this include the ability for storefronts to trigger a notification on a end-user's device when they are in a location that is nearby, telling them that there is a sale on \textbf{TODO: Put another practical example in here}.
% 
% \textbf{Paragraph regarding the need for apps to be responsive, due to the tendency of users to not spend all that long actually using the app...highlight that it is even more important for web-enabled applications, which rely on the internet for their content}
% 
% \textbf{need to cite a source here...a study of how long user's typically use apps for}
% 
% \textbf{Modern online social networks are particularly content rich...while a small number of users of the social networks will only account for a relatively small amount of content, as the networks to greater numbers of users, so does the content, making the retrieval of content of more difficult and more resource intensive}
% 
% \textbf{This report presents a possible solution to the problem of organising data for location-sensitive social networking application}


% Objectives of the report:
% - Outline (in some detail) the problem faced by high-traffic internet services when providing data to a lot of different people
% 
% - Be more specific to the problem we face (mobile social networking application, location-based data retrieval)
% 
% - Cover some of the general guidelines to solving these kinds of problems
% 
% - Describe scenarios which we are likely to encounter
% 
% - Describe and implement a possible solution to the problem
% 
% - Test the proposed solution against the scenarios we devised
% 
% - Discuss the performance of the solution we have proposed and comment upon aspects in which it has been successful and aspects in which it has been a failure
% 
% - Based on the performance of the solution, suggest other solutions (or at least solution details) that we may be able to explore to address shortcomings of the proposed solution