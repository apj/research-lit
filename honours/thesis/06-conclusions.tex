%!TEX root = thesis.tex

\chapter{Conclusions}
\label{cha:conclusions}

Studies investigating the evolution of software systems have provided valuable insight in how software grows and changes throughout the lifetime of its development. However there is currently a gap in the knowledge of software evolution in regard to the vocabulary used in software and whether it is similarly influenced by the process of evolution as the software in its entirety.

In this study, we analysed the vocabularies extracted from the source code of over thirty Java {\OSYS} to gain a greater understanding of the impact of evolution upon the growth and distribution of source vocabularies.

\section{Contributions} % (fold)
\label{sec:contributions}

The key contributions in this research effort are:

\begin{itemize}
		
	\item We showed that vocabularies continue to grow throughout evolution  as new terminology is introduced. The trend that emerged from our analysis was that early versions are responsible for the most growth and that the growth rate slows down over time. We found that in most cases the rate of growth of vocabulary matches that of the overall system size, though the growth rate for vocabulary was slower than the growth rate system size. Furthermore, the vocabulary and system size exhibited similar patterns in terms of which versions contributed the most growth.

	\item We observed how vocabularies are utilised within source code relating to the frequency with which terms are used. Our findings were that there is an inclination to use a small percentage of terms with high frequency, while the majority of the vocabulary is used sparingly. Overall, the distribution of terms was similar to that found within natural-language documents, supporting the findings of Pierret and Poshyvanyk \cite{Pierret09a} and Delorey \etal \cite{Delorey09a}.

\item We investigated changes in the application of vocabulary to determine the influence that evolution has upon how frequently terms are used, finding that developers the relative frequency with which the most popular terms are used increases over time. Generally, terms that were introduced in early versions of the software were the most frequently re-used indicating that the age of a term provides some indication as to its likelihood of being re-used. This was particularly true of terms that were introduced with a high frequency. We found that terms relating to the domain and design patterns were the consistently amongst the most frequently used across all of the systems we analysed.
	
	\item We determined whether the laws of software evolution \cite{Lehman97a} extend to source code vocabulary, findings support for the following laws: First law \emph{Continuing Change}, fifth law \emph{Conservation of Familiarity}, and the sixth law \emph{Continuing Growth}. However, our analysis was unable to provide evidence to show support for the other laws.

\end{itemize}

% section contributions (end)

\section{Future Work} % (fold)
\label{sec:future_work}

In this section, we suggest some possibilities for future research in the area of source code vocabularies and their evolution.

\subsubsection{Integration into Reverse Engineering Tooling} % (fold)
\label{ssub:integration_into_reverse_engineering_tooling}

Across each of the systems that were analysed within this study, a common theme was for the most popularly used terms to refer to domain and architectural concepts, arguably terms which hold the highest semantic value within the vocabulary used by programmers. This holds potential value in being able to reverse engineer domain models and design and architectural elements from the vocabulary used in the source code and provide an insight as to how these aspects of the software have evolved over time. Future work in this regard would be in the refinement of the vocabulary extraction technique used and integration of the extraction tooling into reverse engineering tools, such as ArgoUML\footnote{ArgoUML UML modelling tool \url{http://argouml.tigris.org/}}. This could allow a reduction in the size of the models extracted by focusing only components that are relevant to the domain, helping to improve visual communication.

% subsubsection integration_into_reverse_engineering_tooling (end)

\subsubsection{Modular Level Analysis} % (fold)
\label{ssub:modular_level_analysis}

As our study focused primarily on the source code vocabulary as a single evolving entity, the next step is to examine vocabulary at a finer granularity. This would involve analysis at the module/package level, with the goal of gaining a more precise understanding of the drivers of vocabulary change and being able to localise the origin of changes. Analysis at this level of detail would also paint a more detailed picture of how vocabulary is applied within a system, allowing us to determine whether certain terms are used throughout the system or only within certain modules and the association between modules based on shared terminology.

% subsubsection modular_level_analysis (end)

\subsubsection{Semantic Vocabulary Clustering} % (fold)
\label{ssub:semantic_vocabulary_clustering}

Our study was effective in being able to highlight terms in the vocabulary that were of a high semantic value based on the popularity of their usage. However, not knowing the context in which these terms are used is a limitation in regard to understanding what the terms mean and how they relate to the rest of the vocabulary. Applying semantic clustering techniques \cite{Blei03a, Kuhn07a} to group related terminology will provide greater knowledge of the mental model of the developers are how they have linked terminology together to form applied meaning within their source code.

% subsubsection semantic_vocabulary_clustering (end)

% section future_work (end)

Over the years, studies investigating how software evolves have given an insight into how software grows and changes through continual development efforts. However, the literature in the area of software evolution has thus far neglected an important component in facilitating program comprehension, the vocabulary which is used by developers within source code. This thesis contributes an understanding of how developers build and apply vocabulary within source code and how evolution influences the growth of vocabulary and how terms are used.