%!TEX root = thesis.tex
\chapter{Introduction}
\label{chapter:Introduction} 

% Opening parapraph suggested by Raj - 

% Software systems are large, complex and are a substantial corpus of text. Language used by programmers is rich with semantic information

% \textbf{TODO: Use this chapter to give an overview of the study (i.e. set the stage, provide a motivating problem, highlight why the problem is substantial enough to warrant study and cover attempts to solve the problem)}

\textbf{Notes:}
\textbf{Might be able to cut out the first sentence and make the second sentence the leading sentence}

\textbf{computer is boring...better word?}

\textbf{'Write code'/'writing code' -- repeated phrase!}

\textbf{Throw some citations in here}

Software systems are large, complex entities assembled by developers using source code --- the fundamental building block for contemporary software --- which communicates to the computer how an application should behave. Collectively, the source code that makes up even a small software system represents a substantial corpus of text, which is, in most cases, almost entirely written by humans. While there is an obligation on the developers part to ensure that the source code is written in a manner in which it can be executable by the system upon which it is designed for, developers have the liberty of using expressive language in writing their code.

Utilising this freedom, developers are able to write code that is rich in semantic information regarding not only the purpose of the application and the domain in which it operates, but also the manner in which it has been designed and implemented. Such information is crucial in facilitating the development of mental models, which allow an adequate and consistent comprehension of the software for the developers involved in its construction.

% \textbf{Could probably briefly highlight that software does change and why here, as it will strengthen our argument that mental models will have to change for software evolution}

As software evolves to include new functionality for those who intend to use it, there will inherently be changes within the codebase to support this evolution, bringing about new concepts that require representation within the software and an associated vocabulary used to describe these concepts. This in turn requires the developers to adjust their mental models of the software, which can often be an expensive and timely process.

To preserve the important elements of the mental models formed of software systems and ease the adaptation to include new information, changes in vocabulary can be captured within representative vocabulary that is external to the source code or other such information. While this approach can be useful, it is only effective if it is consistently maintained and up to date with what is present within the source code.

\textbf{Need to clean up this paragraph a bit}

With this in mind, the question naturally arises: \emph{How are vocabularies established and what effect does the process of software evolution have upon them?}

In this thesis we investigate the ways in which programmers use language to form a vocabulary of terms within source code (\textbf{re: distribution of terms}), how vocabularies grow to support growth in the software itself \textbf{re: growth in number of unique terms} and the changes in how vocabulary is applied as the software evolves \textbf{re: rich tokens}. Additionally, we investigate the laws of software evolution in the context of source code vocabulary determine their applicability in describing evolution of the source code vocabulary.

\section{Research Goals} % (fold)
\label{sec:research_goals}

This study aims to provide an understanding of the nature of vocabulary within the source code of software systems and the impact that the process of software evolution has upon source code vocabulary.

\textbf{Not happy with this paragraph -- needs a stronger/clearer argument}

The study is driven by the desire to understand how vocabularies are built and distributed within software systems, how these properties change and in what stages of the software's evolution such changes occur. This knowledge can aid developers and managers in capturing and maintaining documentation for a vocabulary representative of that which is used within the source code by outlining terms which may be fundamental to the system, and by highlighting substantial changes in the vocabulary, giving a clearer indication of when the vocabulary should be documented and what requires documentation. This understanding can be also be applied in the comparison of different types of software systems, to assess the quality and complexity of the vocabulary that has been established and the viability of using the software system.

The goal of this research is to provide a descriptive model of how vocabularies are established and then changed throughout the lifetime of a software system, with the aim of identifying patterns of source code vocabulary evolution that will allow a general understanding of the nature of the evolution, as opposed to investigating activities of software evolution that are the cause of changes to the vocabulary.

% section research_goals (end)

\section{Research Approach} % (fold)
\label{sec:research_approach}

\textbf{TODO: Rewrite/complete writing this section once we can be a little bit more precise about the approach}

What is the approach to addressing the problem?
- Stats for the dataset we used (x classes, open source systems)
- Data extraction (Mutations)

We study open source Java software systems to due their non-restrictive licensing and available, in fact we use X number for this study.

We extract metric information from the software systems JARs and prepare a representation of the history for the system.

Then, we extract identifiers from the class files and extract individual words from the identifiers to build a representative vocabulary present within the system.

\textbf{TODO: Bit more detail about what we are trying to find using the measures we used}

We then utilise the vocabularies we have extracted for each of the versions and examine certain aspects. We use frequency distribution histograms and the Gini coefficient to measure the distribution of terms within the vocabulary and how this changes over time.

% section research_approach (end)

\section{Main Research Outcomes} % (fold)
\label{sec:main_research_outcomes}

% In this thesis...
% - we address the gap in understanding of how source code vocabulary evolves, by finding that vocabulary is established early on and refined, added to in short bursts over time.
% 
% - Certain terms are re-used and permeate throughout the system and some are specific to modules. There is a definite conservation of familiarity!
% 
% - Distribution of terms is highly skewed (this matches the findings of Zipf law, confirming earlier work)
% 
% Investigated Lehman's Laws with regard to vocabulary...found support for x, y, z laws. 

\emph{In this thesis, we address the problem of identifying how vocabularies are established in software systems, the ways in which they grow to support new terms and the changes in how the set of terms within the vocabulary is applied within the source code.}

This thesis makes the following contributions to the body of knowledge of source code vocabulary evolution:

Firstly, we investigated how vocabularies are formed within source code, relating to the collection of terms within the vocabulary and the frequency at which terms are applied across the system. We found that the manner in which term usage is distributed throughout the source code is similar to that of the distribution of words within natural-language corpora, repeating the findings of \cite{Pierret09a}.

Secondly, we investigated the nature of growth exhibited by source code vocabularies. We found that in all but a few \textbf{(quantify)} cases, the growth rate of the vocabularies is clearly sub-linear, indicating that the vocabularies will only grow to a certain extent, at which point further growth is only very minor. Through further analysis of the growth, we determine that a large number of new terms that attribute to the growth of the vocabulary are not heavily used within the source code, and thus, should not constitute a significant part in the mental model of developers.

Thirdly, we investigated how the usage of terms within the source code changes as the software is subject to evolution, finding that developers have a preference for frequent re-use of a relatively small number of terms across different versions of a software system, but that some terms are utilised only a small number of times within parts of the codebase and then never again.

Finally, we assessed the applicability of the laws of software evolution proposed by Lehman \cite{Lehman80a,Lehman97a} in describing the evolution of source code vocabularies. Through our assessment, we support for the First law \emph{Continuing Change}, fourth law \emph{Conservation of Organisational Stability}, fifth law \emph{Conservation of Familiarity}, and the sixth law \emph{Continuing Growth}. Despite this, our analysis was unable to provide evidence to show support for the other laws.

% section main_research_outcomes (end)

\section{Thesis Organisation} % (fold)
\label{sec:thesis_organisation}

\textbf{Background} provides an overview of research in the area of natural language vocabulary, software mental models and source code vocabulary and motivates this study.

\textbf{Methodology} outlines our approach to the selection of data for our study, the corpus that has been selected and the means of extracting vocabularies from the code for our analyses.

\textbf{Findings} highlights our findings in terms of the establishment and evolution of vocabularies within software systems.

\textbf{Summary} concludes the thesis and present opportunities for future work. In this chapter, we summarise our contributions resultant from the work within the thesis.

% section thesis_organisation (end)