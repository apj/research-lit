%!TEX root = thesis.tex
\chapter{Background}
\label{chapter:Background}

\textbf{Chapter Introduction}

\section{Vocabulary and Linguistics} % (fold)
\label{sec:vocabulary_and_linguistics}

\textbf{TODO: Get a tighter definition of vocabulary}

\textbf{Tidy up flow of this paragraph...just a brain dump for now}

\textbf{Need to be more effective selling the importance of vocabularies here}

\textbf{Will of course need citations of work studying how vocabulary is formed, the importance of vocabulary, how it changes, etc.}

- Vocabulary describes the collection of words that one has learnt and is able to recall.

- We build vocabularies in order to more adequately and consistently describe things we encounter.

- Broadening vocabularies can allow us to be more expressive and precise with our communication.

- But terms can be synonymous or polysemic depending upon context, meaning we have to choose our words carefully.

- Humans don't quite have the capacity to expand their vocabularies to cover a language-worth of terms, so our brain will prioritise it's capacity to remember terms that are of most important and most frequent use to us.

- This allows to be more effective with our vocabularies

- While vocabularies are flexible in order to suit our needs...their development comes over time and it is not practical to uproot it all at once

What are the key components to building an effective natural language vocabulary...how can these principles be applied to building other types of vocabularies.

- Linguistics play a role in our comprehension of something (how we relate to it/understand it with the building blocks we know)

% section vocabulary_and_linguistics (end)

\section{Mental Models} % (fold)
\label{sec:mental_models}

Mental models describe our cognitive process in regard to comprehension of things we are exposed to 

We build mental models as they allow us an understanding of something that is more akin to each individuals way of thinking

Team mental models are important, so that team members comprehensions of something are not wildly different (though not all the same -- different perspectives can be a good thing...) -- need to have a consistent representation of a problem if they are to work towards to a well-formed solution.

Languages play a significant role in building mental models, as we as humans associate our understanding with something using the language we have acquired that can be used to describe it.

% section mental_models (end)

\section{Source Code Vocabulary} % (fold)
\label{sec:source_code_vocabulary}

When it comes to source code vocabulary, there are very few boundaries regarding vocabulary

We have conventions and idioms that are popular adhered to, but not enforced ... (getters, setters, general principles for naming things...)

Problems addressed by software are so varied, that vocabularies will be different across different domains

There is more to represent in source code vocabulary than just the terminology relating to the domain, etc, which begs the question? What exactly constitutes vocabulary in source code?

Delorey \etal proposed a few definitions of vocabulary ... eventually settling on (one) because (the reason they chose)

\textbf{Delorey noted that we lack an adequate definition of vocabulary within the context of source code -- proposed levels at which we could define vocabulary...their study included just about everything as part of the vocabulary -- even operators}

\textbf{Abebe et al. split the vocabulary across multiple levels of abstraction (class name, attribute name, method name, comment, etc.)}

Lexicon Bad Smells ... \cite{Abebe09b}

Analyzing the Evolution of the Source Code Vocabulary \cite{Abebe09a}

Mining Programming Language Vocabularies From Source Code \cite{Delorey09a}
 
The Programmer's Lexicon \cite{Host07a}

\textbf{Mining vocabularies}

An Algorithm for Suffix Stripping ... \cite{Porter1997a}

An empirical comparison of techniques for extracting concept abbreviations ... \cite{Feild06a}

Exploring Java software vocabulary ... \cite{Linstead09a}

Recovering documentation to source code traceability ... \cite{Marcus03a}

% section source_code_vocabulary (end)

\section{Software Mental Models} % (fold)
\label{sec:software_mental_models}

% TODO: Should cite work on users mental models of software...Don't Make Me Think? Find some good HCI stuff for here

Software systems are complex entities, rich with conceptual information relating to the domain in which it operates and the problems it attempts to solve \cite{Biggerstaff93a}. Users of software face the challenges of establishing adequate comprehension of what a piece of software is designed to do and how it aligns with what they want it to do. Accordingly, users must develop a mental model of the software in order for it to be useful for their purpose.

% TODO: Need a citation for OO and design patterns being closely related to natural patterns of thinking

Developers have the responsibly of not only understanding how the software works, but also to communicate to a computer how it should behave and to other developers how it is constructed. Fortunately, developers are able to rely heavily on real-world objects and metaphors in communicating to other developers how a software system has been built. The use of programming paradigms such as object-oriented programming and design patterns allow a cognitive map for developers to apply traditional thinking within a software context. However, this freedom of expression is a double-edged sword, as developers are by no means obliged to be communicative when writing code.

\textbf{Concepts, domain terms}

Numerous studies have investigated the quality of identifiers within source code \cite{Abebe09b,Caprile00a,Caprile99a,Deissenboeck06a,Lawrie06a,Lawrie06b,Lawrie07a,Takang96a}. In \cite{Deissenboeck06a}, Dei{\ss}enb\"{o}ck and Pizka define a formal model for well-formed identifiers, with rules for \emph{concise} and \emph{consistent} naming. Lawrie \etal perform an empirical investigation of 78 systems based upon this model to determine whether programmers conform to these rules in their code, revealing that developers frequently violated these rules \textbf{TODO: How frequently? Need some numbers here}. Lawrie \etal examine the impact of identifier completeness upon the comprehension of developers \cite{Lawrie06a}. In their study, they assess the ability of over 100 developers to comprehend function identifiers at three different levels of completeness --- \emph{single letters}, \emph{abbreviations}, and \emph{full words} --- based on well-known algorithms and production code samples. Their study showed that full word identifiers lead to the highest level of comprehension, although in a lot of cases the difference between abbreviation and full word identifiers was negligible.

% section software_mental_models (end)

\section{Natural Language vs. Programmer Language} % (fold)
\label{sec:natural_language_vs_programmer_language}

Corpus Linguistics ... \cite{Biber98a} 
Corpus Linguistics ... \cite{McEnery01a}
Selective Studies (Zipf) \cite{Zipf49a}

Studies of natural language/corpus linguistics have shown us that there are tendencies for humans to apply language in a particular way within natural language documents.

These studies have allowed us to develop ways in which we can assist in the production of text corpora (how?)

Lots of studies have been undertaken in the field of natural language. These studies have been effective in providing an understanding of how humans learn, process and use language.

Programming Languages, Natural Languages and Mathematics ... \cite{Naur75a}

While programs are written using terms that are close to that of natural language, there is little knowledge as to whether the two are exactly the same.

Mining Programming Vocabularies ... \cite{Delorey09a}

An Empirical Exploration of Regularities in Open-Source Software Lexicons ...\cite{Pierret09a}

However, we suspect that there are some similarities between the two which would allow us to apply what we know of natural language to programmer languages
 
Investigation of the similarities between the language used in source code and the language used in natural language corpora indicate that there are definite similarities between the two, opening the door for the possibility of the application of natural language analysis techniques to source code.

\textbf{Outline studies that have investigated the similarities between the two, what success they had and what they claimed it could yield}

% section natural_language_vs_programmer_language (end)

\section{Software Evolution} % (fold)
\label{sec:software_evolution}

% section software_evolution (end)

\section{Source Code Vocabulary Evolution} % (fold)
\label{sec:source_code_vocabulary_evolution}

While there have been numerous studies that have investigated the nature of evolution of source code within software systems, which have given an idea of what to expect through various stages of evolution \textbf{(Cite some!)}; what is unclear is how the vocabulary that is captured within the source code evolves, as the system itself evolves.

It would be reasonable to assume that --- given the vocabulary of the source code is a core part of the source code itself --- it would be subject to the same evolutionary pressures. Antoniol \etal compared the evolution of the source vocabulary and that of the program structure \cite{Antoniol07a}, with a particular focus on their stability. Their study found that the vocabulary (or \emph{lexicon}, as they referred to it) exhibited a high level of stability --- higher than that of the program structure for all versions of the software systems they analysed. While they were able to find a correlation between the two, with major changes in structure yield similarly significant changes in the lexicon, they noted that the underlying distributions between the two were statistically different.

\cite{Antoniol07a} also investigated the frequency of changes to program entities (methods/functions) resultant from identifier refactoring, with the results showing that changes to the lexicon brought about via renaming are very rare, implying developers are hesitant to alter the names of entities within a program once they have been put in place. They speculate that this is due to a reluctance of developers to bring about substantial changes to their mental model of the software.

Abebe \etal \cite{Abebe09a} found that the size of the system and the vocabulary exhibit similarities in their evolution.

Their study established separate vocabularies for the different levels of abstraction within source code, including \emph{class name}, \emph{attribute name}, \emph{function name}, \emph{parameter name} and \emph{comment} vocabularies. Interestingly, they found that of the vocabularies they had established, the comment vocabulary was the largest contributor to evolution of the vocabulary and rich in representation of the entire vocabulary, containing over $ \frac{3}{4} $ of the terms found in any of the vocabularies.

Additionally, they investigated the introduction of new identifiers within a release, to determine whether they were bringing about new terms or whether there was a tendency towards re-use of existing terms. Their findings were that new identifiers consisted of only existing terms in 56\% percent and 70\% of cases for ALICE and WinMerge respectively.

% section source_code_vocabulary_evolution (end)

\section{Summary} % (fold)
\label{sec:summary}

Summary

% section summary (end)

\textbf{TODO: Tie together scraps from NV to put this chapter together properly}

%%%%% Notes

%%% Software Mental Models

% Software systems are large and complex entities, and understanding them in their entirety is difficult
% 
% Like other complex things, we will form a mental model of software in order to understand and have a part in building a system 
% 
% Software mental models are built using elements that are known to have been successful in mental models of real-world entities
% e.g. consistent use of vocabulary
% 
% Software is build to solve problems/address pain points. Naturally, as these problems relate to everyday things that we do, we will build our software systems as such.
% 
% This includes usage of concepts and metaphors (such as design patterns, construction idioms) which are applied generally to the construction of software systems.
% 
% ...
% 
% But also, the usage of language closely related to the conceptual elements involved in the problems we are trying to solve. 
% 
% ...
% 
% This is especially important in bridging the gap in understanding between those that write the source code and those motivating it's construction \textbf{TODO: Need slightly better wording for this...essentially meaning to say that source code is only easy for coders to understand, but coders are not the only ones involved in the construction}
% 
% As a software system gets bigger and bigger, naturally so will its codebase. This is especially true when the software is becoming increasingly more rich in terms of new and novel functionality.
% 
% As this happens, there is a need to:
% - Disambiguate terms in source code (polysemy, etc.)
% - Be expressive in terms of use identifiers and what their purpose is
% - Ensure the different concepts being introduced are adequately distinguished from those which exist.
% 
% \textbf{Need work that has been done on the preservation of mental models in terms of software vocabulary and why it fails, necessitating work in the area}

% The Concept Assignment Problem ... \cite{Biggerstaff93a}
% 
% if one wants to create, maintain, explain, re- engineer, reuse or document a program, one must possess both forms of computational intent. What is more, one must understand the association between the	formal	and	the	informal	expressions	of computational intent. -- The Big Dog
% 
% A person understands a program because they are able to relate the structures of the program and its environment to their human oriented conceptual knowledge about the world. -- The Big Dog
% 
% Role of mental representation \cite{Hoc77}
% 
% The Ramp-Up Problem in Software Projects ... Software Immigrants naturalize\cite{Sim98a}
% 
% Cognitive perspectives on the role of ... \cite{Liblit06a}
% 
% Software developers build a mental model of the software through the use (and reuse) of a set of terms that represent their understanding of the system.
% 
% \textbf{Cover the different elements that form a programmer's mental model. Idioms, best practices, patterns, metaphors, concepts, domain terms, etc.}
% 
% \textbf{Cover domain terms...Marcus, Biggerstaff, Ohba, etc.}
% On the use of domain terms ... \cite{Haiduc08a}
% The Concept Assignment Problem ... \cite{Biggerstaff93a}
% 
% \textbf{TODO: Need some material on the role patterns/metaphors play in software}
% 
% \textbf{Cover idioms/best practices...Host}
% The Programmer's Lexicon ... \cite{Host07a}
% Understanding Programmer Language ... 
% 
% \textbf{Cover studies of identifier quality...Caprile, Tonella, Takang}
% 
% \textbf{Most studies thus far have focussed on micro-elements of the source code -- e.g. identifier quality/comprehension, rather than the vocabulary as an entity composed of terms}
% Assessing the relevance .... \cite{Anquetil98a}
% Nomen est omen\cite{Caprile99a}
% Investigates the linguistic elements of function identifiers...they develop a tool that extract these lexical elements
% 
% Restructuring program identifier... \cite{Caprile00a}
% 
% 
% What's in a name? .... \cite{Lawrie06a}
% Synatctic identifier conciseness ...\cite{Lawrie06b}
% An empirical study of rules for well-formed ... \cite{Lawrie07a}
% Lexicon bad smells ... \cite{Abebe09b}

%%% Natural Language vs. Programmer Language

% Lots of studies have been undertaken in the field of natural language. These studies have been effective in providing an understanding of how humans learn, process and use language.
% 
% While programs are written using terms that are close to that of natural language, there is little knowledge as to whether the two are exactly the same.
% 
% \textbf{Studies of applicability of Zipf's law to source code, Delorey}
% 
% Investigation of the similarities between the language used in source code and the language used in natural language corpora indicate that there are definite similarities between the two, opening the door for the possibility of the application of natural language analysis techniques to source code.

%%% Source Code Vocabulary Evolution

% Studies have shown that software evolves in a non-trivial manner ...
% 
% We have some idea how software evolves ... \textbf{(might want to expand this into a section)}
% 
% One would expect that vocabulary would exhibit similar evolution to that of the system which it belongs to.
% 
% But is the evolution of vocabulary similar to that of the system or different altogether
% 
% Studies into this area have shown there are some similarities ...
% 
% System size and vocabulary evolve comparably, with the lexicon being more stable than the system structure
% 
% Sub-vocabularies evolve at differing rates...comment vocabulary accounts for the most growth in vocabulary and contains 75 percent of all terms
% 
% Still, the following areas are unclear ...
%